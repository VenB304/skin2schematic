import time
try:
    from litemapy import Schematic, Region, BlockState
except ImportError:
    print("Error: litemapy not found. Please install it.")
    raise

class SchematicBuilder:
    def __init__(self, name="SkinStatue", author="Skin2Schematic"):
        self.name = name
        self.author = author
        self.blocks = {} # (x, y, z) -> block_id

    def add_block(self, x, y, z, block_id):
        if block_id:
            self.blocks[(x, y, z)] = block_id

    def save(self, output_path: str):
        if not self.blocks:
            print("Warning: No blocks to save!")
            return

        # Determine bounds
        min_x = min(k[0] for k in self.blocks)
        min_y = min(k[1] for k in self.blocks)
        min_z = min(k[2] for k in self.blocks)
        max_x = max(k[0] for k in self.blocks)
        max_y = max(k[1] for k in self.blocks)
        max_z = max(k[2] for k in self.blocks)

        width = max_x - min_x + 1
        height = max_y - min_y + 1
        length = max_z - min_z + 1

        print(f"Schematic Size: {width}x{height}x{length}")

        reg = Region(0, 0, 0, width, height, length)
        schem = Schematic(name=self.name, author=self.author, regions={"Main": reg})
        
        # Metadata
        schem.description = f"Generated by Skin2Schematic on {time.strftime('%Y-%m-%d %H:%M:%S')}"
        # schem.mc_version = 1 # Not sure about format, skipping explicit version logic if not int standard
        # Looking at dir(), it has 'mc_version'. Let's trust defaults or specific if known.
        # User wanted "1.21.11". litemapy might expect int or defaults to int. 
        # Attempting to assign string might fail if it enforces type. 
        # Let's inspect default safely or just use description/author which are strings.


        count = 0
        for (x, y, z), block_id in self.blocks.items():
            # Offset to Region 0,0,0
            lx = x - min_x
            ly = y - min_y
            lz = z - min_z
            
            # Litemapy uses setblock(x, y, z, BlockState)
            try:
                reg.setblock(lx, ly, lz, BlockState(block_id))
                count += 1
            except Exception as e:
                print(f"Error setting block {block_id} at {lx},{ly},{lz}: {e}")

        schem.save(output_path)
        print(f"Saved {count} blocks to {output_path}")
