import time
try:
    from litemapy import Schematic, Region, BlockState, TileEntity
    from nbtlib import Compound, String, Int, List
except ImportError:
    print("Error: litemapy or nbtlib not found. Please install litemapy.")
    raise

class SchematicBuilder:
    def __init__(self, name="SkinStatue", author="Skin2Schematic"):
        self.name = name
        self.author = author
        self.blocks = {} # (x, y, z) -> block_id

    def add_block(self, x, y, z, block_id):
        if block_id:
            self.blocks[(x, y, z)] = block_id

    def add_sign(self, x, y, z, text, wall_sign=False, facing="north"):
        """
        Adds a sign at the specified location.
        :param x, y, z: Coordinates
        :param text: Text to display (will be split into lines if needed or just first line)
        :param wall_sign: If True, use wall_sign block.
        :param facing: Block state 'facing' property (north, south, east, west)
        """
        # Logic to be implemented in save() or stored in a separate list
        if not hasattr(self, 'signs'):
            self.signs = []
        self.signs.append({
            'x': x, 'y': y, 'z': z,
            'text': text,
            'wall': wall_sign,
            'facing': facing
        })

    def save(self, output_path: str):
        if not self.blocks:
            print("Warning: No blocks to save!")
            return

        # Determine bounds
        min_x = min(k[0] for k in self.blocks)
        min_y = min(k[1] for k in self.blocks)
        min_z = min(k[2] for k in self.blocks)
        max_x = max(k[0] for k in self.blocks)
        max_y = max(k[1] for k in self.blocks)
        max_z = max(k[2] for k in self.blocks)

        # Include signs in bounds? usually inside or near.
        if hasattr(self, 'signs') and self.signs:
            min_x = min(min_x, min(s['x'] for s in self.signs))
            min_y = min(min_y, min(s['y'] for s in self.signs))
            min_z = min(min_z, min(s['z'] for s in self.signs))
            max_x = max(max_x, max(s['x'] for s in self.signs))
            max_y = max(max_y, max(s['y'] for s in self.signs))
            max_z = max(max_z, max(s['z'] for s in self.signs))

        width = max_x - min_x + 1
        height = max_y - min_y + 1
        length = max_z - min_z + 1
        
        # Pad bounds slightly? No.

        print(f"Schematic Size: {width}x{height}x{length}")

        reg = Region(0, 0, 0, width, height, length)
        schem = Schematic(name=self.name, author=self.author, regions={"Main": reg})
        
        # Metadata
        schem.description = f"Generated by Skin2Schematic on {time.strftime('%Y-%m-%d %H:%M:%S')}"

        count = 0
        for (x, y, z), block_id in self.blocks.items():
            lx = x - min_x
            ly = y - min_y
            lz = z - min_z
            try:
                reg.setblock(lx, ly, lz, BlockState(block_id))
                count += 1
            except Exception as e:
                print(f"Error setting block {block_id} at {lx},{ly},{lz}: {e}")

        # Process Signs
        if hasattr(self, 'signs'):
            from litemapy import TileEntity, BlockState
            from nbtlib import Compound, String, Int, List
            
            for s in self.signs:
                lx = s['x'] - min_x
                ly = s['y'] - min_y
                lz = s['z'] - min_z
                
                # Set Block
                block_id = "minecraft:oak_wall_sign" if s['wall'] else "minecraft:oak_sign"
                # Need block state properties? 
                # BlockState("minecraft:oak_sign[rotation=8]")
                # Default standing sign rotation 0=South? 8=North?
                # Simple approximation:
                if s['wall']:
                    bs_str = f"{block_id}[facing={s['facing']}]"
                else:
                    # Standing sign. Rotation 0-15. 
                    # facing="north" -> rotation=8 ?
                    rot_map = {"north": 8, "south": 0, "east": 4, "west": 12}
                    rot = rot_map.get(s.get('facing', 'south'), 0)
                    bs_str = f"{block_id}[rotation={rot}]"
                
                try:
                    reg.setblock(lx, ly, lz, BlockState(bs_str))
                    
                    # Create Tile Entity
                    # Litemapy might handle TE automatically if we just make NBT?
                    # No, we must instantiate TileEntity and add to reg.tile_entities.
                    
                    # NBT Format for Sign (1.20+ uses front_text/back_text messages json, but 1.21 might be strictly components? 
                    # 1.20.4+ -> 'front_text': {'messages': ['"text"', ...]}
                    # Pre-1.20 -> Text1, Text2...
                    # Let's try uniform modern format (1.20+)
                    
                    msg_json = f'{{"text":"{s["text"]}"}}'
                    
                    # Using nbtlib types
                    nbt = Compound({
                        "id": String("minecraft:sign"),
                        "x": Int(lx), # Local or Global? Litematic usually uses relative in regions? 
                                      # Wait, in Litematic 'TileEntities' list, coordinates are usually Absolute? 
                                      # Actually, usually they match the block position. 
                                      # In a Schematic object, if origin is 0,0,0, then relative=absolute.
                                      # Reg is 0,0,0 based. So lx, ly, lz.
                        "y": Int(ly),
                        "z": Int(lz),
                        "front_text": Compound({
                            "messages": List([
                                String(msg_json),
                                String('{"text":""}'),
                                String('{"text":""}'),
                                String('{"text":""}')
                            ])
                        }),
                        "is_waxed": Int(0)
                    })
                    
                    te = TileEntity(nbt)
                    reg.tile_entities.append(te)
                    
                except Exception as e:
                    print(f"Error adding sign at {lx},{ly},{lz}: {e}")

        schem.save(output_path)
        print(f"Saved {count} blocks to {output_path}")

try:
    from litemapy import Schematic, Region, BlockState, TileEntity
    from nbtlib import Compound, String, Int, List
except ImportError:
    pass # Handled at top level usually, but this is safe refactor location logic? 
         # The top has try/except. Let's just assume they exist since top check passed.
         # Actually, let's just rely on the top level import for BlockState/Region.
         # We need to add TileEntity/nbtlib imports to top.

# Move this to top of file
# But for now, fixing the loop logic.

# In 'save':
        # Process Signs
        if hasattr(self, 'signs'):
            for s in self.signs:
                lx = s['x'] - min_x
                ly = s['y'] - min_y
                lz = s['z'] - min_z
                
                # Set Block
                block_id = "minecraft:oak_wall_sign" if s['wall'] else "minecraft:oak_sign"
                
                # BlockState properties
                props = {}
                if s['wall']:
                    props["facing"] = str(s['facing'])
                else:
                    rot_map = {"north": 8, "south": 0, "east": 4, "west": 12}
                    rot = rot_map.get(s.get('facing', 'south'), 0)
                    props["rotation"] = str(rot)
                
                try:
                    # Construct BlockState with ID and Props
                    # BlockState("minecraft:oak_sign", {"rotation": "8"})
                    reg.setblock(lx, ly, lz, BlockState(block_id, props))
                    
                    msg_json = f'{{"text":"{s["text"]}"}}'
                    
                    # NBT
                    nbt = Compound({
                        "id": String("minecraft:sign"),
                        "x": Int(lx),
                        "y": Int(ly),
                        "z": Int(lz),
                        "front_text": Compound({
                            "messages": List([
                                String(msg_json),
                                String('{"text":""}'),
                                String('{"text":""}'),
                                String('{"text":""}')
                            ])
                        }),
                        "is_waxed": Int(0)
                    })
                    
                    te = TileEntity(nbt)
                    reg.tile_entities.append(te)
                    
                except Exception as e:
                    print(f"Error adding sign at {lx},{ly},{lz}: {e}")

        schem.save(output_path)
        print(f"Saved {count} blocks to {output_path}")
