import time
try:
    from litemapy import Schematic, Region, BlockState, TileEntity
    from nbtlib import Compound, String, Int, List
except ImportError:
    print("Error: litemapy or nbtlib not found. Please install litemapy.")
    raise

# Monkeypatch litemapy to fix OverflowError with large ints (Python 3.14 / Numpy 2 compat)
import litemapy.storage
def patched_setitem(self, index: int, value: int) -> None:
    index = int(index) # Ensure index is python int (fixes numpy contamination)
    if not 0 <= index < len(self):
        raise IndexError("Invalid index {}".format(index))
    if not 0 <= value <= self._LitematicaBitArray__mask: # Access private via name mangling or getattr
        # In patched method, self.__mask becomes self._LitematicaBitArray__mask
        raise ValueError("Invalid value {}, maximum value is {}".format(value, self._LitematicaBitArray__mask))
            
    start_offset = index * self.nbits
    start_arr_index = start_offset >> 6
    end_arr_index = ((index + 1) * self.nbits - 1) >> 6
    start_bit_offset = start_offset & 0x3F
    m = (1 << 64) - 1
    
    # Force int conversion to avoid numpy overflow issues
    current_val = int(self.array[start_arr_index])
    mask = int(self._LitematicaBitArray__mask)
    
    zeroed = current_val & ~(mask << start_bit_offset)
    updated = zeroed | (int(value) & mask) << start_bit_offset
    self.array[start_arr_index] = int(updated & m)

    if start_arr_index != end_arr_index:
        end_offset = 64 - start_bit_offset
        j1 = self.nbits - end_offset
        
        current_end = int(self.array[end_arr_index])
        
        # self.array[end_arr_index] = (self.array[end_arr_index] >> j1 << j1 | (value & self.__mask) >> end_offset) & m
        # Break it down safely
        term1 = (current_end >> j1) << j1
        term2 = (int(value) & mask) >> end_offset
        self.array[end_arr_index] = int((term1 | term2) & m)

litemapy.storage.LitematicaBitArray.__setitem__ = patched_setitem

class SchematicBuilder:
    def __init__(self, name="SkinStatue", author="Skin2Schematic"):
        self.name = name
        self.author = author
        self.blocks = {} # (x, y, z) -> block_id

    def add_block(self, x, y, z, block_id):
        if block_id:
            self.blocks[(x, y, z)] = block_id

    def add_sign(self, x, y, z, text, wall_sign=False, facing="north"):
        """
        Adds a sign at the specified location.
        :param x, y, z: Coordinates
        :param text: Text to display (will be split into lines if needed or just first line)
        :param wall_sign: If True, use wall_sign block.
        :param facing: Block state 'facing' property (north, south, east, west)
        """
        if not hasattr(self, 'signs'):
            self.signs = []
        self.signs.append({
            'x': x, 'y': y, 'z': z,
            'text': text,
            'wall': wall_sign,
            'facing': facing
        })

    def add_blocks_bulk(self, coords_matrix, block_ids):
        """
        Bulk add blocks.
        coords_matrix: (N, 3) numpy array
        block_ids: (N,) list or array of strings
        """
        # Convert to tuple keys and update dict 
        # (This is still python overhead but faster than individual calls)
        # Using zip is reasonably fast.
        
        # Ensure block_ids is iterable
        if len(coords_matrix) != len(block_ids):
            print("Warning: Bulk add mismatch")
            return
            
        # Optimization: Map to list of tuples
        keys = map(tuple, coords_matrix)
        self.blocks.update(zip(keys, block_ids))

    def save(self, output_path: str):
        if not self.blocks:
            print("Warning: No blocks to save!")
            return

        # Determine bounds
        min_x = min(k[0] for k in self.blocks)
        min_y = min(k[1] for k in self.blocks)
        min_z = min(k[2] for k in self.blocks)
        max_x = max(k[0] for k in self.blocks)
        max_y = max(k[1] for k in self.blocks)
        max_z = max(k[2] for k in self.blocks)

        # Include signs in bounds? usually inside or near.
        if hasattr(self, 'signs') and self.signs:
            min_x = min(min_x, min(s['x'] for s in self.signs))
            min_y = min(min_y, min(s['y'] for s in self.signs))
            min_z = min(min_z, min(s['z'] for s in self.signs))
            max_x = max(max_x, max(s['x'] for s in self.signs))
            max_y = max(max_y, max(s['y'] for s in self.signs))
            max_z = max(max_z, max(s['z'] for s in self.signs))

        width = max_x - min_x + 1
        height = max_y - min_y + 1
        length = max_z - min_z + 1

        print(f"Schematic Size: {width}x{height}x{length}")

        reg = Region(0, 0, 0, width, height, length)
        schem = Schematic(name=self.name, author=self.author, regions={"Main": reg})
        
        # Metadata
        schem.description = f"Generated by Skin2Schematic on {time.strftime('%Y-%m-%d %H:%M:%S')}"

        count = 0
        for (x, y, z), block_id in self.blocks.items():
            lx = x - min_x
            ly = y - min_y
            lz = z - min_z
            try:
                reg.setblock(lx, ly, lz, BlockState(block_id))
                count += 1
            except Exception as e:
                print(f"Error setting block {block_id} at {lx},{ly},{lz}: {e}")

        # Process Signs
        if hasattr(self, 'signs'):
            for s in self.signs:
                lx = s['x'] - min_x
                ly = s['y'] - min_y
                lz = s['z'] - min_z
                
                # Set Block
                block_id = "minecraft:oak_wall_sign" if s['wall'] else "minecraft:oak_sign"
                
                # BlockState properties
                props = {}
                if s['wall']:
                    props["facing"] = str(s['facing'])
                else:
                    rot_map = {"north": 8, "south": 0, "east": 4, "west": 12}
                    rot = rot_map.get(s.get('facing', 'south'), 0)
                    props["rotation"] = str(rot)
                
                try:
                    # Construct BlockState with ID and Props
                    reg.setblock(lx, ly, lz, BlockState(block_id, **props))
                    
                    msg_json = f'{{"text":"{s["text"]}"}}'
                    
                    # NBT
                    # NBT
                    # We include BOTH modern (1.20+ front_text) and legacy (Text1-4) formats
                    # to ensure compatibility.
                    
                    nbt_dict = {
                        "id": String("minecraft:sign"),
                        "x": Int(lx),
                        "y": Int(ly), 
                        "z": Int(lz),
                        "is_waxed": Int(0)
                    }
                    
                    # Modern (1.20+)
                    nbt_dict["front_text"] = Compound({
                        "messages": List([
                            String(msg_json),
                            String('{"text":""}'),
                            String('{"text":""}'),
                            String('{"text":""}')
                        ]),
                        "has_glowing_text": Int(0),
                        "color": String("black")
                    })
                    nbt_dict["back_text"] = Compound({
                        "messages": List([
                            String('{"text":""}'),
                            String('{"text":""}'),
                            String('{"text":""}'),
                            String('{"text":""}')
                        ]),
                        "has_glowing_text": Int(0),
                        "color": String("black")
                    })

                    # Legacy (Pre-1.20)
                    nbt_dict["Text1"] = String(msg_json)
                    nbt_dict["Text2"] = String('{"text":""}')
                    nbt_dict["Text3"] = String('{"text":""}')
                    nbt_dict["Text4"] = String('{"text":""}')

                    nbt = Compound(nbt_dict)
                    
                    te = TileEntity(nbt)
                    reg.tile_entities.append(te)
                    
                except Exception as e:
                    print(f"Error adding sign at {lx},{ly},{lz}: {e}")

        schem.save(output_path)
        print(f"Saved {count} blocks to {output_path}")
